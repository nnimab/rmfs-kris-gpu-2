# 更新日誌 (Changelog)

本文件包含項目的所有重要更改。

## [配置中] v0.5.5 (2025-06-15)

### 主要更新：MCP Serena 開發環境配置

*   **版本描述**：此版本為專案添加了 MCP Serena 語言服務器支援所需的配置文件，以提升開發體驗和程式碼智能分析能力。

#### 主要活動
*   **專案配置標準化**: 創建了 `pyproject.toml` 文件，定義了專案的元數據、依賴關係和構建配置。
*   **開發環境優化**: 新增了 `.vscode/settings.json` 配置文件，設定了 Python 解釋器路徑、程式碼分析路徑和開發工具設定。
*   **語言服務器整合**: 嘗試激活 MCP Serena 以提供進階的程式碼智能功能。

#### 技術細節
*   配置了 Python 3.8+ 相容性設定
*   設定了專案模組路徑（ai, world, lib, evaluation, utils）
*   配置了程式碼格式化（Black）和類型檢查（MyPy）工具
*   設定了虛擬環境路徑為 `./.venv/Scripts/python.exe`

#### 產出
*   新增: `pyproject.toml` - Python 專案配置文件
*   新增: `.vscode/settings.json` - VS Code 工作區設定
*   新增: `pyrightconfig.json` - Pyright 語言服務器配置

#### 修改的文件
*   新增: `pyproject.toml` - 專案配置和依賴管理
*   新增: `.vscode/settings.json` - VS Code 開發環境設定
*   新增: `pyrightconfig.json` - Pyright 語言服務器配置，包含專案路徑和執行環境設定
*   修改: `CHANGELOG.md` - 更新版本資訊

#### 問題排除
*   嘗試了多種 MCP Serena 激活方法，包括重啟語言服務器和初始化專案
*   創建了必要的配置文件以支援語言服務器檢測專案

## [已驗證] v0.5.4 (2025-06-15)

### 主要更新：完成專案總體審查與控制器深度分析

*   **版本描述**：此版本標誌著對整個專案，特別是四個核心控制器（時間基、隊列基、DQN、NERL）的系統性深度審查工作的完成。此舉確保了團隊對現有程式碼的全面理解，並為後續優化奠定了基礎。

#### 主要活動
*   **控制器邏輯審查**: 逐一分析了四個控制器的決策依據、算法流程與實現細節。
*   **正確性驗證**: 將程式碼實現與 `CHANGELOG.md` 中的歷史描述進行比對，確認邏輯一致性。
*   **潛在問題識別**: 識別出各控制器中潛在的設計缺陷與可改進點，例如隊列基控制器的飢餓問題、DQN/NERL的狀態空間限制等。
*   **效能指標審查**: 對 `evaluation/performance_report_generator.py` 中的所有KPI進行了審查，分析了其計算邏輯與意義，並提出了新增指標（如公平性、完成率、路徑冗餘度）的建議。

#### 產出
*   在 `審查報告/` 目錄下創建了四份詳細的控制器分析報告以及一份效能指標分析報告，為專案知識庫增加了重要文檔。

#### 修改的文件
*   新增: `審查報告/效能指標分析報告.md`
*   修改: `開發計畫.md` - 更新審查任務狀態。
*   修改: `CHANGELOG.md` - 更新版本資訊。

## [已驗證] v0.5.0 (2025-03-12)

### 主要更新：實現基於神經進化的強化學習控制器 (NERL Controller)

* **版本描述**：此版本實現了基於神經進化強化學習的交通控制器，使用進化算法而非梯度下降來優化神經網絡策略。

#### 新增功能
* 新增 `ai/controllers/nerl_controller.py` 文件，實現 NEController 類
* 實現可進化的神經網絡 EvolvableNetwork 類，用於進化算法優化
* 使用與DQN控制器相同的狀態空間和獎勵設計，便於公平比較
* 實現進化算法核心機制：
  * 精英保留策略保存最佳個體
  * 錦標賽選擇機制選擇父代
  * 均勻交叉產生子代個體
  * 高斯變異引入多樣性
* 添加了基於進化間隔的訓練機制，定期更新族群
* 支持模型保存和加載功能，便於持續訓練

#### 技術細節
* 族群規模為40個策略個體，每代保留8個精英個體
* 交叉率0.7，變異率0.15，變異強度0.1
* 每15個時間步執行一次進化操作
* 保留最佳個體用於推理模式
* 設計支持多核心CPU並行評估的架構

#### 修改的文件
* 新增: `ai/controllers/nerl_controller.py` - 實現NERL控制器和可進化神經網絡
* 修改: `CHANGELOG.md` - 更新版本信息

## [已驗證] v0.5.1 (2025-03-20)

### 增強 NERL 控制器的 NetLogo 集成

* **主要更新**:
  - 添加 NetLogo 接口函數，實現與 NERL 控制器的完整集成。
  - 支持從 NetLogo 設置、訓練和評估 NERL 控制器。

* **新增功能**:
  - 添加 `set_nerl_controller` 函數，支持從 NetLogo 設置 NERL 控制器。
  - 添加 `set_nerl_training_mode` 函數，支持切換訓練/評估模式。
  - 更新 `list_available_models` 函數，支持列出可用的 NERL 模型。
  - 更新 `IntersectionManager.update_traffic_using_controller` 方法，支持 NERL 控制器的訓練機制。

* **使用說明**:
  - 設置控制器: `set-nerl-controller`
  - 加載預訓練模型: `set-nerl-controller exploration-rate 0 load-model-tick 20000`
  - 切換為評估模式: `set-nerl-training-mode false`
  - 查看可用模型: `list-available-models "nerl"`

* **修改的文件**:
  - 更新 `netlogo.py`
  - 更新 `world/managers/intersection_manager.py`
  - 更新 `CHANGELOG.md`

## [已驗證] v0.5.2 (2025-03-25)

### 更新 README，添加 NERL 控制器使用說明

* **主要更新**:
  - 完善項目 README 文檔，添加 NERL 控制器的詳細使用說明和參數說明。
  - 更新系統架構圖，加入 NERL 控制器。

* **添加的內容**:
  - NERL 控制器架構、參數和運行機制的詳細說明
  - 在 NetLogo 中使用 NERL 控制器的具體步驟和命令示例
  - 訓練模式和評估模式的切換說明
  - 模型加載和查看說明

* **參數說明**:
  - 添加了 NERL 控制器的所有可配置參數的詳細說明，包括種群規模、交叉率、變異率等
  - 解釋了進化間隔和進化機制

* **修改的文件**:
  - 更新 `README.md`
  - 更新 `CHANGELOG.md`

## [已驗證] v0.5.3 (2025-03-27)

### 添加 NERL 控制器界面按鈕到 NetLogo

* **主要更新**:
  - 將 NERL 控制器的功能整合到 NetLogo 界面，添加了操作按鈕，提升使用體驗。
  - 完善界面設計，使 NERL 控制器與其他控制器使用方式一致。

* **新增功能**:
  - 添加 `NERL控制器` 按鈕，用於快速設置基本 NERL 控制器
  - 添加 `NERL(加載模型)` 按鈕，支持加載預訓練的 NERL 模型
  - 添加 `NERL訓練模式開/關` 按鈕組，用於切換訓練和評估模式
  - 添加 `list-models-by-type` 函數，支持按控制器類型查看可用模型

* **界面設計**:
  - NERL 控制器按鈕位置與 DQN 控制器按鈕相對應，保持界面一致性
  - 訓練模式切換按鈕使用開/關設計，直觀明了
  - 所有新增功能均與已有 Python 後端接口完美整合

* **使用說明**:
  - 點擊 `NERL控制器` 按鈕設置基本控制器
  - 使用滑桿選擇模型 Tick，點擊 `NERL(加載模型)` 加載預訓練模型
  - 點擊 `NERL訓練模式開/關` 切換控制器模式
  - 在命令行使用 `list-models-by-type "nerl"` 查看可用的 NERL 模型

* **修改的文件**:
  - 更新 `rmfs.nlogo` - 添加界面按鈕和命令函數
  - 更新 `CHANGELOG.md` - 記錄新版本更新內容

## [已驗證] v0.4.4 (2025-03-09)

### 修復：圖表標題和檔案名稱顯示正確的控制器名稱

* **問題描述**：修復了切換不同控制器後，生成的圖表標題和檔案名稱顯示為"none"而不是實際控制器名稱的問題。

#### 問題原因
* 在設置新控制器時沒有正確更新`performance_reporter`的`controller_name`屬性
* `PerformanceReportGenerator`類的初始化方法將控制器名稱預設為"none"
* 在生成圖表和保存檔案時沒有檢查控制器名稱的有效性

#### 解決方案
* 修改`netlogo.py`中的`set_traffic_controller`函數，確保更新`performance_reporter`的控制器名稱
* 修改`PerformanceReportGenerator`類的`__init__`方法，從warehouse對象獲取控制器名稱
* 改進`save_time_series_data`方法，確保檔案名稱不使用"none"作為控制器名稱
* 修改圖表生成相關方法，確保圖表標題和檔案名稱使用正確的控制器名稱

#### 修改的文件
* 修改: `netlogo.py` - 更新`set_traffic_controller`函數，傳遞控制器名稱到`performance_reporter`
* 修改: `evaluation/performance_report_generator.py` - 改進控制器名稱處理邏輯，確保圖表和檔案名稱正確
* 修改: `CHANGELOG.md` - 更新版本信息

## [已驗證] v0.4.3 (2025-03-08)

### 改進：添加時間序列數據收集和圖表生成功能

* **版本描述**：此版本添加了時間序列數據收集和圖表生成功能，使用戶能夠追蹤和視覺化KPI隨時間的變化趨勢。

#### 功能改進
* 添加了時間序列數據收集機制，可在模擬過程中定期記錄關鍵績效指標
* 實現了基於matplotlib的圖表生成功能，支持單一指標和多指標比較圖表
* 添加了數據統計和趨勢分析功能，包括平均值和趨勢線的計算與展示
* 優化了數據存儲和管理方式，使用JSON格式保存時間序列數據
* 修改了報告生成流程，集成了圖表生成功能

#### 技術細節
* 在PerformanceReportGenerator類中實現了時間序列數據收集方法
* 定義了集成到模擬tick循環中的數據收集機制
* 實現了單一指標圖表和多指標比較圖表的生成
* 添加了圖表美化和資訊增強功能，如平均線、趨勢線等
* 建立了圖表自動保存和管理系統

#### 修改的文件
* 修改: `evaluation/performance_report_generator.py` - 添加時間序列數據收集和圖表生成功能
* 修改: `netlogo.py` - 集成時間序列數據收集到tick循環和報告生成流程
* 修改: `CHANGELOG.md` - 更新版本信息

## [已驗證] v0.4.2 (2025-03-07)

### 改進：優化關鍵性能指標(KPI)的計算方法

* **版本描述**：此版本改進了三個關鍵性能指標的計算方法，使其更準確地反映模擬結果。

#### 功能改進
* 改進了平均交叉口流量計算方法，從瞬時快照改為單位時間內的實際流量
* 改進了平均交叉口等待時間計算方法，使用更精確的等待時間記錄
* 改進了機器人平均利用率計算方法，從瞬時狀態改為基於整個模擬過程的時間記錄
* 添加了各種輔助方法，以便更準確地收集和分析性能數據

#### 修改的文件
* 修改: `world/entities/intersection.py` - 添加交叉口流量和等待時間記錄
* 修改: `world/entities/robot.py` - 添加機器人活動時間記錄
* 修改: `evaluation/performance_report_generator.py` - 使用新的計算方法生成KPI

## [已驗證] v0.4.1 (2025-03-06)

### 改進：優化綜合性能報告生成器

* **版本描述**：此版本改進了綜合性能報告生成功能，使其可以直接從 Warehouse 對象獲取性能指標，而不依賴於結果文件。

#### 功能改進
* 重構 `evaluation/performance_report_generator.py`，添加直接從 Warehouse 對象生成報告的功能
* 修改 `netlogo.py` 中的 `generate_report()` 函數，使用直接從 Warehouse 對象生成報告的方法
* 確保所有調適日誌使用英文，提高兼容性
* 新增已完成訂單數量和耗時幾個ticks完成的性能指標，提供更全面的性能評估

#### 修改的文件
* 修改: `evaluation/performance_report_generator.py`
* 修改: `netlogo.py`
* 修改: `CHANGELOG.md`

## [已驗證] v0.4.0 (2025-03-06)

### 主要更新：實現綜合性能報告生成器

* **版本描述**：此版本實現了綜合性能報告生成功能，以便比較不同交通控制器的效能。

#### 新增功能
* 新增 `evaluation/performance_report_generator.py` 文件，實現 PerformanceReportGenerator 類
* 新增性能報告生成按鈕到 NetLogo 界面
* 實現各種關鍵績效指標(KPIs)的計算和記錄：
  * 總能量消耗
  * 平均訂單處理時間
  * 機器人利用率
  * 交叉口等待時間
  * 停止-啟動次數
  * 每個路口的流量
  * 交叉口擁堵程度
  * 完成全部訂單所需的總時間
* 新增 `netlogo.py` 中的 `generate_report()` 函數，用於從 NetLogo 調用報告生成
* 修改 `warehouse.py`，添加 `current_controller` 屬性以跟踪當前使用的控制器

#### 修改的文件
* 新增: `evaluation/performance_report_generator.py`
* 新增: `evaluation/__init__.py`
* 修改: `netlogo.py`
* 修改: `rmfs.nlogo`
* 修改: `world/warehouse.py`

## [已驗證] v0.3.0 (2025-03-05)

### 主要更新：實現基於深度強化學習的交通控制器 (DQN Controller)

* **版本描述**：此版本實現了基於深度強化學習的交通控制器，利用深度Q網絡(DQN)優化交叉路口的交通管理。

#### 新增功能
* 新增 `ai/controllers/dqn_controller.py` 文件，實現 DQNController 類
* 實現狀態空間設計，包含8個特徵：
  * 當前允許的方向編碼
  * 自上次信號變化以來的時間
  * 水平/垂直方向的機器人數量
  * 水平/垂直方向的優先級機器人數量
  * 水平/垂直方向的平均等待時間
* 實現動作空間設計，包含3個可能的動作
* 實現防鎖死機制，避免機器人長時間等待
* 整合獎勵計算邏輯，考慮等待時間、能源消耗等因素
* 支持訓練/推理兩種模式
* 支持模型保存和加載功能

#### 技術細節
* 從隊列控制器繼承任務優先級權重設計
* 結合基於規則的判斷與深度強化學習決策
* 使用歸一化處理確保狀態表示的穩定性
* 提供定期訓練和模型保存機制

#### 錯誤修復
* 修復了 DQN 控制器中的 'Intersection' 對象缺少屬性問題：
  * 修改了 `dqn_controller.py` 中的 `get_reward` 方法，不再直接訪問交叉路口的能源消耗和停止-啟動屬性
  * 改為迭代交叉路口中的所有機器人，獲取並累計它們的能源消耗和停止-啟動次數
  * 添加了 `hasattr` 檢查以提高代碼穩健性
  * 解決了訓練過程中出現的 `AttributeError: 'Intersection' object has no attribute 'current_intersection_energy_consumption'` 錯誤

#### README 文檔更新
* 完善了 DQN 控制器的文檔，提供詳細的實現細節和使用指南
* 添加了關於狀態空間、動作空間和獎勵函數的完整描述
* 添加了神經網絡架構和訓練機制的說明

## [已驗證] v0.2.0 (2025-03-13)

### 主要更新：優化隊列控制器和交叉路口控制邏輯

* **版本描述**：此版本主要對交通控制系統進行了顯著優化，特別是隊列控制器的實現和應用。

* **主要變更**：
  1. **移除 DQN 控制器**：暫時移除了 DQN 強化學習控制器，以集中精力優化基於規則的控制策略。
  2. **重寫隊列控制器**：完全重構了隊列控制器的實現：
     - 移除舊版隊列控制器的不穩定實現
     - 新版控制器具有更穩定的決策邏輯
     - 真正實現了基於優先級的隊列控制效果
  3. **控制範圍限制**：將隊列控制器限制為只應用於主要交叉路口(15,15)：
     - 便於隔離測試控制器的效果
     - 在高流量區域驗證控制邏輯
  4. **減少死鎖**：大幅減少了頻繁觸發死鎖機制的情況：
     - 優化了交叉路口通行邏輯
     - 提高了交通流量的穩定性

* **技術改進**：
  1. 在 `ai/controllers/queue_based_controller.py` 中實現了新版隊列控制器
  2. 在 `world/managers/intersection_manager.py` 中修改了控制器應用邏輯
  3. 完善了機器人方向判斷和分類邏輯
  4. 優化了標記為粉紅色的主要交叉路口(15,15)的交通控制

* **下一步計劃**：
  1. 基於新控制邏輯的成果，重新引入並改進 DQN 控制器
  2. 繼續優化隊列控制器的決策機制
  3. 擴展控制器應用範圍至多個關鍵交叉路口
  4. 進一步減少系統死鎖和等待時間

## v0.2.1 (2025-03-14)

### 重構：通用化控制器應用範圍

* **版本描述**：作為 `v0.2.0` 版本下一步計劃的實現，此版本重構了控制器的應用機制，使其更具通用性。

* **主要變更**：
  1. **移除特定路口限制**：移除了先前版本中將隊列控制器僅應用於主要交叉路口 (15, 15) 的限制。
  2. **實現通用應用邏輯**：在 `world/managers/intersection_manager.py` 中更新了 `update_traffic_using_controller` 方法，使當前選擇的任何交通控制器（無論是隊列、時間、DQN或NERL）都能統一應用於系統中的所有交叉路口。
  3. **統一控制架構**：此變更建立了一個更靈活和統一的控制架構，便於未來擴展和測試新的控制器類型。

* **變更原因**：
  - 這是對 `v0.2.0` 版本中提出的「擴展控制器應用範圍至多個關鍵交叉路口」計劃的直接實踐。與其逐一指定多個路口，我們選擇了更具擴展性的方案，即應用於所有路口。

* **修改文件**：
  - `world/managers/intersection_manager.py`：修改了 `update_traffic_using_controller` 方法。

## v0.1.25 (2025-03-12)

### 修復：機器人方向轉換時的分類問題

* **問題描述**：修復了機器人從水平方向轉為垂直方向（或反之）時沒有被正確重新分類的問題。用戶反映主要交叉路口(15,15)能夠正確檢測水平方向的機器人，但當機器人從水平轉向垂直方向時，它仍然被視為水平方向的機器人，導致垂直方向的機器人計數不準確。

* **原因分析**：
  1. 原`updateRobot`方法僅檢查機器人是否已在某個方向列表中，然後更新該列表的機器人對象，而不重新評估其方向
  2. 一旦機器人被分類為水平或垂直，即使它改變了朝向或位置，這個分類也不會被更新
  3. 這導致在轉彎時的機器人仍然保持其原始分類，即使它實際上已經改變了方向
  4. 特別是在主要交叉路口(15,15)，這個問題會導致垂直方向的機器人計數不準確

* **解決方案**：
  1. 完全重構了`updateRobot`方法，增加了機器人方向重新評估機制：
     - 首先確定機器人當前的分類（水平或垂直）
     - 根據機器人的位置和朝向重新評估其應該被分類的方向
     - 如果分類發生變化，從舊集合中移除並添加到新集合
  2. 使用與`addRobot`方法相同的評估標準來確保一致性：
     - 基於位置的精確比較
     - 基於朝向的分類
  3. 添加詳細的調試輸出，特別是對於主要交叉路口(15,15)的方向轉換情況

* **技術說明**：
  1. 新的方法計算機器人位置與交叉路口的差值，並決定其屬於哪個方向
  2. 實現了機器人在交叉路口內部移動時的動態重新分類
  3. 對於方向變化的情況，提供了專門的日誌輸出，幫助監控和診斷問題
  4. 特別處理了機器人在交叉路口附近但不在標準軸線上的情況，使用朝向來輔助判斷方向

* **修改文件**：
  - `world/entities/intersection.py`：重構了`updateRobot`方法，改進了機器人方向重新分類的邏輯

## v0.1.24 (2025-03-11)

### 修復：垂直方向機器人無法被主要交叉路口(15,15)正確檢測的問題

* **問題描述**：修復了垂直方向的機器人無法被主要交叉路口(15,15)檢測到的問題。用戶反映水平方向的機器人能被正確檢測，但垂直方向的機器人即使接近或穿越交叉路口，也未被添加到交叉路口的垂直機器人列表中。

* **原因分析**：
  1. 在`Intersection`類的`addRobot`方法中，機器人分類為垂直或水平方向的判斷邏輯過於嚴格，要求坐標完全相等（`robot.pos_x == self.coordinate.x`）
  2. 由於浮點數精度問題，機器人的實際坐標可能與整數坐標存在微小偏差
  3. 對於非完全對齊的機器人（如對角線接近路口的機器人），沒有根據其行進方向來正確分類
  4. 主要交叉路口作為重要節點，需要更靈活的機器人檢測和分類機制

* **解決方案**：
  1. 重構了`addRobot`方法，使用更寬容的坐標比較機制：
     - 將嚴格的相等比較改為差值比較，允許0.5單位的誤差
     - 引入基於朝向(heading)的機器人分類機制，heading為0或180的機器人分類為垂直方向，heading為90或270的分類為水平方向
     - 為主要交叉路口(15,15)添加詳細的調試輸出，幫助診斷問題
  2. 擴大了機器人分類的範圍，對於在交叉路口3單位範圍內但不在明確的水平或垂直線上的機器人，根據其朝向來分類

* **技術說明**：
  1. 新的分類邏輯使用`abs(robot.pos_x - self.coordinate.x) < 0.5`替代`robot.pos_x == self.coordinate.x`，解決了精度問題
  2. 添加了第三種情況，處理接近但不在標準軸線上的機器人
  3. 為主要交叉路口添加了專門的調試輸出，包括機器人位置、交叉路口位置、座標差值等信息
  4. 特殊情況下利用機器人的heading來輔助判斷其行進方向，提高分類的準確性

* **修改文件**：
  - `world/entities/intersection.py`：修改了`addRobot`方法，改進了機器人方向分類的邏輯

## v0.1.23 (2025-03-11)

### 修復：主要交叉路口(15,15)無法檢測附近機器人的問題

* **問題描述**：修復了主要交叉路口(15,15)無法正確檢測附近機器人的問題。用戶反映即使有機器人穿越主要交叉路口，系統日誌仍然顯示水平和垂直方向都沒有機器人（robots: 0）。

* **原因分析**：
  1. 在`findIntersectionByCoordinate`方法中，對主要交叉路口(15,15)的檢測邏輯有錯誤
  2. 邏輯結構嵌套不當，形成了`if distance <= 2 && if intersection_x == 15 && if distance <= 3`的三重條件判斷
  3. 這導致只有同時滿足`distance <= 2`和`distance <= 3`的情況才會被檢測到
  4. 由於邏輯結構問題，實際上主要交叉路口的3單位檢測半徑功能未生效

* **解決方案**：
  1. 重構了`findIntersectionByCoordinate`方法中的條件判斷邏輯：
     - 首先檢查交叉路口是否為主要交叉路口(15,15)
     - 如果是主要交叉路口，單獨使用3個單位的檢測半徑
     - 其他一般交叉路口繼續使用2個單位的檢測半徑
  2. 添加了更詳細的距離信息輸出，幫助診斷
  3. 改進了代碼結構，使邏輯更清晰

* **技術說明**：
  1. 修復前，主要交叉路口的特殊檢測條件被嵌套在普通交叉路口的條件內，導致條件互相干擾
  2. 修復後，兩種檢測邏輯分開處理，主要交叉路口優先判斷，確保3單位檢測半徑能夠正確應用
  3. 通過添加詳細的距離信息輸出，可以清楚看到機器人與交叉路口的實際距離

* **修改文件**：
  - `world/managers/intersection_manager.py`：修正了`findIntersectionByCoordinate`方法中的條件判斷邏輯

## v0.1.22 (2025-03-10)

### 修復：擴大交叉路口機器人檢測範圍

* **問題描述**：修復了交叉路口無法正確識別附近機器人的問題。系統日誌顯示即使有機器人靠近交叉路口，交叉路口仍然報告「沒有機器人」（robots: 0）。

* **原因分析**：
  1. 交叉路口檢測邏輯只檢查機器人坐標是否在交叉路口的 `approaching_path_coordinates` 列表中
  2. 這個列表可能沒有包含足夠多的接近路徑坐標
  3. 即使機器人肉眼可見地接近交叉路口，系統也無法將其識別為「在交叉路口區域內」
  4. 特別是對於主要交叉路口(15,15)，需要更大的識別範圍

* **解決方案**：
  1. 增強了 `findIntersectionByCoordinate` 方法，添加基於距離的檢測邏輯：
     - 即使機器人坐標不在預定義的接近路徑中，只要在交叉路口2個單位範圍內，也能被識別
     - 對於主要交叉路口(15,15)，使用更大的3個單位識別半徑
     - 添加調試輸出，記錄檢測到的機器人及其與交叉路口的關係
  
* **技術說明**：
  1. 使用曼哈頓距離（|x1-x2| + |y1-y2|）計算機器人與交叉路口的距離
  2. 保留了原有的基於 `approaching_path_coordinates` 的檢測機制，新機制作為補充
  3. 這種方法更符合直觀認知：即使機器人未完全與交叉路口重疊，也應被視為在交叉路口影響範圍內

* **修改文件**：
  - `world/managers/intersection_manager.py`：修改了 `findIntersectionByCoordinate` 方法，添加基於距離的檢測邏輯

## v0.1.21 (2025-03-08)

### 修復：交叉路口機器人方向判斷邏輯錯誤

* **錯誤描述**：修復交叉路口控制系統中將水平/垂直方向機器人分類錯誤的重大問題。系統之前將在同一x坐標上的機器人（實際上是垂直移動的）錯誤地歸類為"水平機器人"，反之亦然。

* **修復細節**：
  1. 在 `world/entities/intersection.py` 的 `addRobot` 方法中修正了方向判斷邏輯：
     - 現在當機器人和交叉路口在同一x坐標時（上下移動），正確地將其添加到垂直機器人集合
     - 當機器人和交叉路口在同一y坐標時（左右移動），正確地將其添加到水平機器人集合
  
* **影響範圍**：
  1. 此修復將直接影響所有基於機器人方向進行決策的交通控制器，特別是隊列基控制器
  2. 修復後，控制器將能正確識別機器人的實際方向，優先級分配和交通控制將與實際觀察到的交通情況相符
  3. 用戶將不再看到與實際觀察不符的交通控制決策（例如明明水平方向有機器人，但系統顯示垂直方向有機器人）

* **技術說明**：
  1. 問題根源在於方向判斷邏輯的概念錯誤，而非代碼實現錯誤
  2. `isAllowedToMove` 方法已經正確實現，不需要修改
  3. 這個修復不需要改變控制器的算法，只是確保了輸入數據的正確性

* **修改文件**：
  - `world/entities/intersection.py`：修正了 `addRobot` 方法中的方向判斷邏輯

## v0.1.20 (2025-03-06)

### 功能：將隊列基控制器限制為只應用於主要交叉路口

* **功能描述**：修改了隊列基控制器的應用範圍，使其只針對主要交叉路口（坐標15,15）生效，便於隔離測試控制器的效果。

* **實現細節**：
  1. 在 `world/managers/intersection_manager.py` 的 `update_traffic_using_controller` 方法中添加控制邏輯：
     - 檢測當前控制器類型是否為 "queue_based"
     - 如果是隊列基控制器，則只在交叉路口坐標為 (15,15) 時應用控制邏輯
     - 其他類型的控制器（如時間基控制器、DQN控制器）仍舊應用於所有交叉路口
     - 添加特定的調試輸出，清晰顯示主要交叉路口的方向變更情況

* **使用方法**：
  1. 使用與之前相同的方式激活隊列基控制器（點擊 `隊列基控制器` 按鈕）
  2. 控制器現在只會影響標記為粉紅色的主要交叉路口（坐標15,15）
  3. 其他交叉路口將保持其默認狀態或受其他控制方式影響
  4. 控制台將顯示特定的日誌，表明主要交叉路口的方向變更

* **技術說明**：
  1. 實現了一種隔離測試機制，方便觀察和評估隊列基控制器的效果
  2. 不需要修改控制器本身的邏輯，只改變了其應用範圍
  3. 這種方法有助於確定控制器在特定高密度交叉路口的效果，而不受其他交叉路口的干擾

* **修改文件**：
  - `world/managers/intersection_manager.py`：修改了 `update_traffic_using_controller` 方法

## v0.1.19 (2025-03-05)

### 功能：增強隊列基控制器並標註主要路口

* **功能描述**：增強了隊列基控制器，使其能根據機器人任務優先級分配路口通行權，並在界面上標註了主要路口位置。

* **實現細節**：
  1. 在 `ai/controllers/queue_based_controller.py` 文件中重新實現了隊列基控制器：
     - 基於機器人的任務類型（delivering_pod、returning_pod、taking_pod）設定優先級權重
     - 優先考慮送pod去撿貨站的機器人（最高優先級）
     - 其次考慮將pod送回倉庫的機器人（次高優先級）
     - 再次考慮空車機器人去倉庫拿pod（一般優先級）
     - 計算各方向總優先級，決定放行方向

  2. 在 `rmfs.nlogo` 文件的 `setup` 函數中添加主要路口標註：
     - 在坐標 (15, 15) 處使用粉紅色標記主要交叉路口
     - 為路口添加清晰的標籤，方便識別和測試
     - 系統將優先在此路口實施隊列基控制策略

* **使用方法**：
  1. 使用 `setup` 初始化系統時，主要路口將被自動標記為粉紅色
  2. 點擊 `隊列基控制器` 按鈕激活控制器
  3. 可調整 `min-green-time` 參數設置最小綠燈時間（避免頻繁切換）
  4. 可調整 `bias-factor` 參數調整水平/垂直方向的權重偏好

* **技術說明**：
  1. 控制器將根據每個方向的加權優先級總和決定通行方向
  2. 控制台輸出顯示每個路口的水平/垂直優先級和機器人數量（調適用）
  3. 考慮到水平方向通常有更多機器人，引入偏好因子可調整平衡

* **修改文件**：
  - `ai/controllers/queue_based_controller.py`：實現了基於任務優先級的隊列控制器
  - `rmfs.nlogo`：在 setup 函數中添加了主要路口標記

## v0.1.18 (2025-03-02)

### 功能：在 NetLogo 界面顯示當前 tick 值

* **功能描述**：在 NetLogo 界面上添加了顯示當前模擬 tick 值的監視器，方便用戶直觀地了解模擬進度。

* **實現細節**：
  1. 在 `netlogo.py` 的 `tick()` 函數中添加返回 `warehouse._tick` 值：
     - 修改函數返回值列表，增加 tick 值作為結果的一部分
     - 確保 tick 值能夠正確地從 Python 傳遞到 NetLogo 界面

  2. 在 `rmfs.nlogo` 修改：
     - 在 globals 部分添加 `current_tick` 全局變量
     - 修改 `go` 方法，從 Python 結果中獲取 tick 值並設置到全局變量
     - 添加新的 MONITOR 元素顯示 `current_tick` 值

* **使用效果**：
  1. 用戶現在可以在界面上直接看到當前模擬的進度（tick 值）
  2. 有助於與其他模擬指標（如能源消耗、訂單數量等）進行關聯分析
  3. 方便調試和記錄實驗結果時參考具體的時間點

* **修改文件**：
  - `netlogo.py`：修改 `tick()` 函數，返回 tick 值
  - `rmfs.nlogo`：添加全局變量和新的界面顯示元素

## v0.1.17 (2025-02-26)

### 文档：在 README.md 中添加調適訊息控制系統說明

* **功能描述**：在 README.md 中添加了關於 Robot.DEBUG_LEVEL 系統的詳細說明，幫助開發者了解如何控制和使用調適訊息功能。

* **實現細節**：
  1. 在 README.md 中新增了「調適訊息控制系統」章節，包含以下內容：
     - 調適級別（DEBUG_LEVEL）的完整說明（0-無調適、1-重要訊息、2-所有訊息）
     - 如何在代碼中修改 DEBUG_LEVEL 值的實用指南
     - 調適訊息類型的詳細分類（訓練訊息、機器人運動訊息、系統訊息）

  2. 提供了清晰的使用示例，幫助開發者了解如何設置和應用不同的調適級別：
     - 不同場景下的推薦設置（正式環境：0，一般開發：1，深入調試：2）
     - 通過修改 Robot 類中的 DEBUG_LEVEL 靜態屬性來控制全局調適訊息

* **目的與價值**：
  1. 提高開發體驗：開發者可按需控制調適訊息的詳細程度
  2. 標準化調適實踐：建立清晰的調適訊息級別規範
  3. 提升文檔完整性：補充系統調適功能的使用指南
  4. 便於新開發者快速上手：無需閱讀代碼即可了解調適系統

* **修改文件**：
  - `README.md`：添加調適訊息控制系統的詳細說明

## v0.1.16 (2025-02-25)

### 功能：新增 DQN 訓練調適訊息

* **功能描述**：在 DQN 控制器訓練過程中添加調適訊息，方便開發者了解訓練進度和狀態。

* **實現細節**：
  1. 在 `ai/controllers/dqn_controller.py` 中添加訓練開始和目標網絡更新的調適訊息：
     - 在每次訓練開始時輸出訓練步驟和當前時間刻
     - 在目標網絡更新時顯示訊息

  2. 在 `ai/deep_q_network.py` 的 `replay` 方法中添加訓練詳細資訊：
     - 顯示批次大小和記憶庫大小
     - 方便監控訓練樣本的累積情況

* **使用方法**：
  1. 訓練訊息的顯示受 `Robot.DEBUG_LEVEL` 控制，與其他調適訊息一致
  2. 當 `DEBUG_LEVEL > 0` 時顯示訓練相關訊息
  3. 訓練訊息使用英文顯示，以 "[Training]" 作為前綴便於識別

* **修改文件**：
  - `ai/controllers/dqn_controller.py`：添加訓練開始和目標網絡更新訊息
  - `ai/deep_q_network.py`：在 replay 方法中添加訓練詳情訊息

## v0.1.15 (2025-02-24)

### 優化：改進 Robot 調適文字輸出系統

* **問題描述**：Robot 類中的調適訊息（如距離計算、交叉路口檢查等）過多且不加過濾地顯示，干擾了開發和測試過程中的輸出觀察。

* **解決方案**：
  1. 在 `Robot` 類中添加了 `DEBUG_LEVEL` 靜態屬性，用於控制調適訊息的輸出級別：
     - 0：完全不顯示調適訊息
     - 1：只顯示重要調適訊息（如機器人在交叉路口等待時間過長的警告）
     - 2：顯示所有詳細調適訊息

  2. 修改了 `pathBlockedByIntersection` 方法中的調適訊息輸出，根據 `DEBUG_LEVEL` 控制顯示級別。

  3. 修改了 `closeEnough` 方法中的距離檢查調適訊息，只在 `DEBUG_LEVEL > 1` 時顯示。

  4. 修改了 `ensureCoordinate` 方法中的調適訊息，只在 `DEBUG_LEVEL > 1` 時顯示。

  5. 修改了 `netlogo.py` 文件中的 "before tick" 訊息輸出，根據 `Robot.DEBUG_LEVEL` 控制顯示。

* **使用方法**：
  1. 設置 `Robot.DEBUG_LEVEL = 0` 可完全關閉調適訊息，適合正式運行環境。
  2. 設置 `Robot.DEBUG_LEVEL = 1` 可只顯示重要的警告訊息，適合一般開發和測試。
  3. 設置 `Robot.DEBUG_LEVEL = 2` 可顯示所有詳細調適訊息，適合深入調試。

* **預設值**：預設將 `DEBUG_LEVEL` 設為 0，完全關閉調適訊息以獲得清晰的輸出。

* **修改文件**：
  - `world/entities/robot.py`：添加 `DEBUG_LEVEL` 靜態屬性、修改多處 print 語句添加條件判斷
  - `netlogo.py`：修改 `tick` 函數中 "before tick" 訊息的輸出條件

## v0.1.14 (2025-02-23)

### 修復：DQN 控制器缺少 last_state 和 last_action 屬性

* **問題描述**：DQN 控制器在執行過程中出現 `AttributeError: 'DQNController' object has no attribute 'last_state'` 錯誤，導致模擬在 tick 10 左右停止。

* **錯誤原因**：
  1. `DQNController` 類中在 `get_direction` 方法中使用了 `self.last_state` 和 `self.last_action` 屬性。
  2. 但在類的 `__init__` 方法中未初始化這些屬性，導致首次執行時出現 AttributeError。
  3. 這些屬性用於存儲每個交叉路口的先前狀態和動作，用於 DQN 算法中的經驗回放。

* **解決方案**：
  1. 修改 `ai/controllers/dqn_controller.py` 文件中的 `__init__` 方法：
     - 在初始化其他屬性的同時，添加 `self.last_state = {}` 和 `self.last_action = {}` 初始化語句
     - 確保這些屬性被正確初始化為空字典，用於後續存儲交叉路口狀態信息

* **技術細節**：
  - 這兩個屬性是字典類型，使用交叉路口 ID 作為鍵
  - 初始化為空字典，隨著控制器運行逐漸填充各交叉路口的狀態和動作記錄
  - 這些記錄對於實現 DQN 算法中的經驗回放至關重要

* **修改文件**：
  - `ai/controllers/dqn_controller.py`：在 `__init__` 方法中添加 `self.last_state` 和 `self.last_action` 屬性初始化

### 修復：Robot 對象缺少 last_move_tick 屬性問題

* **問題描述**：DQN 控制器在執行過程中出現 `AttributeError: 'Robot' object has no attribute 'last_move_tick'` 錯誤，導致模擬無法繼續運行。

* **錯誤原因**：
  1. 在 `dqn_controller.py` 的 `get_state` 方法中，嘗試訪問 `robot.last_move_tick` 屬性來計算機器人等待時間。
  2. `Robot` 類中並未定義此屬性，導致運行時錯誤。
  3. 這個屬性的目的是為了計算機器人在交叉路口等待的時間，用於 DQN 的狀態向量。

* **解決方案**：
  1. 修改 `ai/controllers/dqn_controller.py` 文件中的 `get_state` 方法：
     - 用 `robot.current_intersection_start_time` 替代不存在的 `last_move_tick` 屬性
     - 添加 null 檢查，確保即使屬性為空也能提供默認值 0
     - 使用列表手動收集等待時間，然後找出最大值，避免列表推導式的潛在問題

* **技術細節**：
  - `current_intersection_start_time` 記錄了機器人進入交叉路口的時間點
  - 通過計算當前時間與進入時間的差值，得到等待時間
  - 對空值進行防禦性處理，確保代碼穩健性
  - 保持狀態向量的維度不變，確保與模型兼容

* **修改文件**：
  - `ai/controllers/dqn_controller.py`：修改 `get_state` 方法中計算等待時間的邏輯

## v0.1.13 (2025-02-22)

### 修復：DQN 控制器中的屬性錯誤問題

* **問題描述**：DQN 控制器在執行過程中出現 `AttributeError: 'Intersection' object has no attribute 'current_intersection_energy_consumption'` 錯誤，導致模擬無法繼續運行。

* **錯誤原因**：
  1. 在 `dqn_controller.py` 的 `get_state` 方法中，嘗試訪問 `intersection.current_intersection_energy_consumption` 和 `intersection.current_intersection_stop_and_go` 屬性。
  2. `Intersection` 類中並未定義這些屬性，導致運行時錯誤。
  3. 這些屬性的目的是取得交叉路口能源消耗和停止啟動次數，但實際實現與設計不一致。

* **解決方案**：
  1. 修改 `ai/controllers/dqn_controller.py` 文件中的 `get_state` 方法：
     - 使用預設值 0.0 替代缺失的能源消耗和停止啟動屬性
     - 確保狀態向量維度一致，保持 DQN 模型的穩定性

  2. 修改 `get_reward` 方法：
     - 替換原本直接訪問 `current_intersection_energy_consumption` 屬性的代碼
     - 改用交叉路口的 `calculateAverageStopAndGo` 方法取得停止啟動統計數據
     - 計算水平和垂直方向的停止啟動次數總和作為獎勵計算依據

* **技術細節**：
  - 狀態向量結構仍維持 8 維，確保與之前訓練的模型兼容
  - 能源消耗暫時設為預設值 0.0，後續可考慮添加能源消耗計算邏輯
  - 停止啟動次數改為基於交叉路口已有的統計函數計算

* **修改文件**：
  - `ai/controllers/dqn_controller.py`：修改 `get_state` 和 `get_reward` 方法

## v0.1.12 (2025-02-21)

### 功能：增強 DQN 控制器的自動保存和加載模型功能

* **功能描述**：為 DQN 控制器添加自動保存里程碑模型功能並增強模型加載機制，方便實驗比較和延續訓練。

* **實現細節**：
  1. 修改了 `ai/controllers/dqn_controller.py` 文件：
     - 添加了在特定 ticks (5000, 10000, 20000) 自動保存模型的功能
     - 增強了 `save_model` 和 `load_model` 方法，支持通過 tick 指定模型版本
     - 優化了模型保存命名規則，清晰區分常規保存和里程碑保存

  2. 修改了 `ai/deep_q_network.py` 文件：
     - 增強了 `load_model` 方法，支持加載指定路徑的模型
     - 添加了模型加載成功與失敗的回傳值，便於上層邏輯處理
     - 優化了模型存儲結構和錯誤處理機制

  3. 修改了 `netlogo.py` 文件：
     - 增強了 `set_dqn_controller` 函數，支持在初始化控制器時加載指定 tick 的模型
     - 添加了 `list_available_models` 函數，用於查詢可用的已保存模型
     - 完善了錯誤處理和日誌輸出，便於診斷模型加載問題

  4. 修改了 `rmfs.nlogo` 文件：
     - 添加了 `model-tick` 滑桿，用於選擇要加載的模型 tick
     - 添加了 `查看模型` 按鈕，用於顯示所有可用的模型
     - 添加了 `DQN(加載模型)` 按鈕，用於加載指定 tick 的預訓練模型
     - 添加了相應的 NetLogo 過程處理模型加載和列表功能

* **使用方法**：
  1. 正常訓練過程中，系統將自動在 5000, 10000, 20000 ticks 保存里程碑模型
  2. 要查看可用的模型，點擊 `查看模型` 按鈕
  3. 要加載預訓練模型，滑動 `model-tick` 滑桿選擇要加載的 tick 值，然後點擊 `DQN(加載模型)` 按鈕
  4. 加載成功後，控制器顯示為 "DQN(loaded)"，表示使用的是已訓練的模型

* **技術注意事項**：
  1. 里程碑模型使用 `dqn_traffic_milestone_{tick}.pth` 命名格式存儲
  2. 每 1000 步的常規保存仍然保留，使用 `dqn_traffic_{tick}.pth` 命名格式
  3. 所有模型都存儲在 `models` 目錄下，確保此目錄的存在和可寫性
  4. 加載模型時會同時更新主網絡和目標網絡，確保一致性

* **修改文件**：
  - `ai/controllers/dqn_controller.py`：增強了模型保存和加載功能
  - `ai/deep_q_network.py`：完善了模型加載機制和錯誤處理
  - `netlogo.py`：添加了模型加載和列表功能
  - `rmfs.nlogo`：更新了界面，添加了模型選擇和加載控件

## v0.1.11 (2025-02-20)

### 優化：完善 DQN 控制器實現

* **功能描述**：完善 DQN (Deep Q-Network) 控制器實現，從簡單的隨機控制策略升級為完整的深度強化學習控制器。

* **實現細節**：
  1. 擴展了 `ai/deep_q_network.py` 文件，實現了完整的 DQN 模型：
     - 增加了 `QNetwork` 神經網絡類，定義了三層神經網絡架構
     - 完善了 `DeepQNetwork` 類，實現了記憶回放、目標網絡、ε-greedy 策略等核心 DQN 功能
     - 增加了模型保存和加載功能，支持訓練中斷和恢復
     - 實現了批量訓練和經驗回放機制，提高學習效率

  2. 重構了 `ai/controllers/dqn_controller.py` 中的 `DQNController` 類：
     - 實現了複雜的狀態特徵提取，包括交叉路口方向、等待機器人數量、能源消耗等
     - 設計了獎勵函數，結合通過機器人數量、能源消耗和停止啟動次數
     - 集成了定期訓練和模型更新機制
     - 添加了自適應探索機制，平衡探索與利用

* **參數配置**：
  1. 狀態空間（state_size）：8 維向量，包括當前方向、持續時間、水平/垂直機器人數量等
  2. 動作空間（action_size）：2，代表 "Horizontal" 和 "Vertical" 兩個方向
  3. 最小綠燈時間（min_green_time）：10 個時間單位，避免頻繁切換方向
  4. 折扣因子（gamma）：0.95，用於平衡當前和未來獎勵
  5. 探索率（epsilon）：初始 1.0，隨時間衰減至 0.01，平衡探索與利用
  6. 目標網絡更新頻率（update_target_every）：100 步

* **預期效果**：
  1. 控制器能夠學習最優的交通控制策略，隨時間提高性能
  2. 系統能自適應地應對不同的交通模式和負載
  3. 平衡效率、能源消耗和停止啟動次數等多個目標
  4. 通過經驗積累不斷改進，逐步超越簡單的啟發式方法

* **技術注意事項**：
  1. 為提高訓練穩定性，使用了目標網絡和主網絡分離的策略
  2. 狀態特徵進行了規範化處理，確保神經網絡輸入穩定
  3. 實現了模型定期保存機制，每 1000 步保存一次
  4. 完整支持 PyTorch 和 CPU/GPU 訓練

* **修改文件**：
  - `ai/deep_q_network.py`：完善了神經網絡模型和 DQN 算法實現
  - `ai/controllers/dqn_controller.py`：完善了 DQN 控制器實現和特徵提取

## v0.1.10 (2025-02-19)

### 優化：進一步增強綠波機制效果解決短距離交叉路口問題

* **問題描述**：優化後的綠波機制（v0.1.9）運行效果仍不理想，尤其是當交叉路口之間距離較短時，機器人仍然在通過一個路口後在下一個路口停下來，降低了運輸效率。

* **問題根因分析**：
  1. 綠波傳播速度問題：綠波「到達」下一個路口的時間與機器人到達的時間不夠同步。
  2. 相鄰路口識別問題：對於距離很短的路口，系統未能正確將它們識別為關鍵的相鄰關係。
  3. 距離衰減過快：原有公式中距離因子的影響過大，導致即使是短距離的相鄰路口間綠波效應也衰減嚴重。
  4. 路口間綠波協調不足：對於特別近的路口，需要更強的綠波影響力。

* **解決方案**：
  1. 將綠波影響因子（green_wave_influence）從 3.0 進一步增加到 5.0，大幅加強綠波對交通方向決策的影響力。
  2. 將綠波傳播時間（green_wave_propagation_time）從 10 個時間單位增加到 15 個時間單位，確保綠波效應能持續更長時間。
  3. 修改距離衰減計算方式，使用平方根距離而非線性距離，降低距離對綠波影響的抑制作用。
  4. 增加基礎影響值（0.5），確保即使距離較遠的路口也能接收到一定程度的綠波影響。
  5. 增加交叉路口相鄰識別距離，從 10 個單位增加到 15 個單位，以便更好地識別和處理短距離路口。
  6. 加強調試輸出，增加詳細的綠波傳播記錄，便於診斷和優化。

* **技術實現細節**：
  - 修改了 `ai/controllers/queue_based_controller.py` 中的綠波影響計算公式:
    ```python
    # 原來: influence = self.green_wave_influence * (1.0 - time_since_change / self.green_wave_propagation_time) / max(1, distance)
    # 現在:
    time_factor = 1.0 - time_since_change / self.green_wave_propagation_time
    distance_factor = 1.0 / max(1, (distance ** 0.5))  # 使用平方根降低距離影響
    base_influence = 0.5  # 基礎影響值
    influence = self.green_wave_influence * time_factor * (distance_factor + base_influence)
    ```
  - 擴大了相鄰交叉路口的識別半徑（從10到15），確保短距離路口能被正確關聯
  - 增加了詳細的綠波傳播記錄，包括影響值、距離、時間等信息

* **預期效果**：
  1. 機器人能夠更流暢地連續通過多個交叉路口，特別是距離較短的相鄰路口
  2. 綠波效應在相鄰路口間傳播更加高效，協調性更強
  3. 整體運輸效率得到進一步提升，減少在短距離路口的停止和等待時間
  4. 系統能適應不同密度的交叉路口分佈，包括非常接近的交叉路口

## v0.1.9 (2025-02-18)

### 優化：加強綠波機制效果與交通控制參數

* **問題描述**：即使實現了綠波機制，機器人仍然無法連續通過多個交叉路口，在經過一個路口後在下一個路口就停下來，降低了運輸效率。

* **優化原因**：
  1. 綠波影響因子設置過低，綠波協調效果不明顯。
  2. 綠波傳播時間太短，無法有效覆蓋機器人從一個交叉路口移動到下一個交叉路口所需的時間。
  3. 最小綠燈時間不足，導致交通信號燈切換過於頻繁，機器人沒有足夠時間通過交叉路口。

* **解決方案**：
  1. 將綠波影響因子（green_wave_influence）從 1.8 增加到 3.0，加強綠波對交通方向決策的影響力。
  2. 將綠波傳播時間（green_wave_propagation_time）從 4 個時間單位增加到 10 個時間單位，確保綠波效應能持續足夠長時間。
  3. 將最小綠燈時間（min_green_time）從 10 增加到 30，給予機器人足夠的通行時間窗口。
  4. 保留水平方向偏好因子（bias_factor），繼續為水平方向提供 1.5 倍的權重優勢。

* **預期效果**：
  1. 機器人能夠連續通過多個交叉路口，減少不必要的停止和等待。
  2. 交通信號燈狀態更加穩定，減少頻繁切換。
  3. 綠波效應能夠有效傳播到相鄰的多個交叉路口。
  4. 整體運輸效率得到顯著提升。

* **技術細節**：
  - 這些參數優化保持了原有交通控制邏輯的完整性，僅調整了關鍵數值參數。
  - 參數調整基於實際運行觀察結果，針對特定的交通流模式進行了優化。
  - 通過增加綠波影響和持續時間，系統能夠更好地協調相鄰交叉路口的交通控制。

## v0.1.8 (2025-02-17)

### 修復：解決 GridPosition 對象序列化問題

* **問題描述**：系統在嘗試保存狀態時出現 `_pickle.PicklingError: Can't pickle <class 'ai.controllers.queue_based_controller.GridPosition'>: attribute lookup GridPosition on ai.controllers.queue_based_controller failed` 錯誤，導致無法完成模擬執行。

* **錯誤原因**：
  1. 在 `initialize_adjacent_intersections` 方法內部使用 `namedtuple` 動態創建了 `GridPosition` 類。
  2. Python 的 `pickle` 模組在序列化時無法在模組級別找到 `GridPosition` 的定義。
  3. 在多個地方重複定義了相同的 `GridPosition` 類，導致類定義不一致。
  4. `namedtuple` 類型在序列化時可能出現問題，特別是當它在動態環境中使用時。

* **解決方案**：
  1. 用自定義的 `GridPosition` 類替換 `namedtuple`，添加完整的類方法和序列化支持。
  2. 實現 `__reduce__` 方法，確保正確的序列化和反序列化。
  3. 添加 `__eq__`、`__hash__` 和 `__repr__` 方法，保持與 `namedtuple` 相同的功能。
  4. 移除方法內部重複的 `GridPosition` 定義，統一使用模組級別的定義。

* **技術細節**：
  - 在模組級別定義了完整的 `GridPosition` 類，取代原來的 `namedtuple`。
  - 實現了 `__reduce__` 方法來支持 `pickle` 序列化，返回 `(GridPosition, (self.x, self.y))`。
  - 添加了比較方法和哈希計算，確保類的實例可以正確地用於字典鍵和集合。
  - 保持與原有代碼的兼容性，確保現有的 `grid_position` 賦值和訪問方式不受影響。

## v0.1.7 (2025-02-16)

### 修復：綠波機制適配性問題

* **問題描述**：綠波機制實現後系統出現 `AttributeError: 'list' object has no attribute 'values'` 錯誤，以及交叉路口缺少 `grid_position` 屬性的警告，導致系統無法正確建立相鄰關係。

* **錯誤原因**：
  1. 在 `initialize_adjacent_intersections` 方法中假設了 `intersection_manager.intersections` 必須是字典類型，而在實際環境中它可能是列表。
  2. 缺少異常處理機制，導致系統在遇到錯誤時直接崩潰。
  3. 多處代碼使用了可能不存在的屬性或方法，沒有進行充分的防禦性編程。
  4. 某些交叉路口沒有 `grid_position` 屬性，但代碼直接訪問此屬性而沒有檢查其存在性。

* **解決方案**：
  1. 修改 `initialize_adjacent_intersections` 方法，增加對 `intersections` 為列表或字典的兼容處理。
  2. 添加全面的異常處理機制，確保在出現問題時系統能夠優雅降級。
  3. 增加調試輸出，幫助診斷綠波機制的工作狀態。
  4. 改進 `track_robot_movement` 和 `get_direction` 方法，增強錯誤處理能力。
  5. 添加屬性存在性檢查，避免訪問不存在的屬性。
  6. 為缺少 `grid_position` 屬性的交叉路口動態創建此屬性，基於其已有的 `coordinate` 或 `pos_x/pos_y` 屬性。

* **技術細節**：
  - 使用 `isinstance()` 函數判斷數據類型，根據不同類型採取不同的處理策略
  - 對於可能失敗的操作使用 `try-except` 塊進行保護
  - 如果初始化失敗，自動禁用綠波功能以避免影響基本交通控制
  - 使用 `getattr()` 安全訪問對象屬性，避免直接屬性訪問可能引發的錯誤
  - 添加回退機制，確保在出現異常時仍能返回合理的默認值
  - 使用 `namedtuple` 動態創建 `grid_position` 屬性，保持與原有屬性同步
  - 增強統計和日誌輸出，記錄缺少屬性的交叉路口數量和建立的連接數

## v0.1.6 (2025-02-15)

### 功能：實現交通綠波協調機制

* **功能描述**：實現綠波（Green Wave）機制，協調多個相鄰交叉路口的交通控制，使機器人能夠連續通過多個交叉路口而不需頻繁停止等待。

* **實現細節**：
  1. 修改 `ai/controllers/queue_based_controller.py` 中的 `QueueBasedController` 類，添加綠波協調功能。
  2. 建立交叉路口相鄰關係映射，識別水平和垂直方向的相鄰路口。
  3. 新增機器人移動軌跡跟踪，記錄機器人經過的交叉路口和方向。
  4. 開發綠波影響因子計算方法，基於相鄰路口狀態、距離和時間關係。
  5. 在交通方向決策邏輯中整合綠波影響權重，增強相鄰路口間的方向協調。

* **參數配置**：
  1. 綠波影響因子（green_wave_influence）：1.8，用於平衡綠波協調與基本交通邏輯。
  2. 綠波傳播時間（green_wave_propagation_time）：4個時間單位，定義綠波效應的持續時間。
  3. 可通過構造函數參數 `green_wave_enabled` 控制是否啟用綠波功能。

* **預期效果**：
  1. 減少機器人走走停停的情況，提高整體運輸效率。
  2. 對於沿同一方向行駛的多個機器人，形成"綠色通道"。
  3. 在保持現有交通控制優勢的同時，引入智能化的路口協調機制。
  4. 系統能自適應地識別主要交通流方向，優先保障主幹道的通行效率。

* **技術注意事項**：
  1. 綠波機制不會覆蓋最小綠燈時間保護，確保交通規則的基本穩定性。
  2. 相鄰路口定義基於坐標距離，最大考慮10個單位距離內的交叉路口。
  3. 加入調試輸出，記錄綠波影響值，便於後續優化。

## v0.1.5 (2025-02-14)

### 修復：強化機器人交叉路口判斷和通行邏輯

* **問題描述**：即使重新設計了隊列基控制器，機器人在某些情況下仍然會卡在交叉路口不動。

* **錯誤原因**：
  1. 在 `pathBlockedByIntersection` 方法中，機器人判斷是否可以通過路口的邏輯過於簡單。
  2. 沒有處理長時間等待的情況，機器人可能無限期地卡在路口。
  3. 距離判斷邏輯（`closeEnough`）可能不夠精確。

* **解決方案**：
  1. 修改 `world/entities/robot.py` 中的 `pathBlockedByIntersection` 方法，添加更詳細的邏輯和調試信息輸出。
  2. 新增等待時間計數機制：每個機器人現在會記錄在每個路口等待的時間。
  3. 添加安全機制：當機器人在路口等待超過30個時間單位時，強制允許通行。
  4. 使用更嚴格的距離判斷標準（從1.0減少到0.8）。

* **技術細節**：
  - 在 `Robot` 類中添加了 `intersection_wait_time` 字典屬性，記錄機器人在每個路口等待的時間
  - 改進了 `pathBlockedByIntersection` 方法，添加了詳細的調試信息和等待時間處理
  - 當機器人等待時間過長時，會強制允許通行，以防止永久卡住的情況
  - 添加了記錄和重置等待時間的邏輯

## v0.1.4 (2025-02-13)

### 改進：重新設計隊列基控制器

* **問題描述**：使用 queue_based_controller.py 時，機器人在交叉路口不動，尤其是當只有一個方向有機器人時。

* **錯誤原因**：
  1. 原始控制器沒有特別處理「只有一個方向有機器人」的情況。
  2. 沒有考慮機器人的任務狀態優先級（如運送中、取貨中等）。
  3. 只計算等待機器人數量，沒有考慮任務重要性。

* **解決方案**：
  1. 在 `ai/controllers/queue_based_controller.py` 中重寫控制器邏輯。
  2. 添加特殊邏輯：當只有一個方向有機器人時，立即允許該方向通行。
  3. 引入機器人狀態權重系統，優先考慮運送任務的機器人。
  4. 改進權重計算方法，用於決定哪個方向應該被允許通行。
  5. 當權重相同且當前沒有設定方向時，預設選擇水平方向。

* **技術細節**：
  - 添加了 `status_weights` 字典，為不同的機器人狀態分配權重
  - 修改 `get_direction` 方法，先檢查是否只有單向交通
  - 使用加權計算替代簡單的計數比較

## v0.1.3 (2025-02-12)

### 修復：完善Landscape類的邊界檢查

* **問題描述**：在`landscape.py`中的多個方法缺少完整的邊界檢查，可能導致在特定情況下出現`IndexError: list index out of range`錯誤。

* **錯誤原因**：以下方法直接訪問地圖數組但沒有足夠的邊界檢查：
  - `getNeighborObject`：完全沒有邊界檢查
  - `setObject`：沒有檢查新位置和舊位置是否有效
  - `_setObjectNew`：沒有檢查坐標是否在有效範圍內

* **解決方案**：
  - 為`getNeighborObject`方法添加了完整的邊界檢查
  - 在`setObject`方法中添加了對新位置和舊位置的檢查
  - 在`_setObjectNew`方法中添加了坐標有效性檢查
  - 所有方法現在都會在訪問`self.map`之前確保坐標在有效範圍內（>= 0且 <= dimension）

* **預防類似問題的建議**：
  - 所有直接訪問數組的操作應該包含完整的邊界檢查
  - 考慮為關鍵數據結構添加包裝方法，統一處理邊界檢查邏輯
  - 添加單元測試以驗證邊界情況下的行為

## v0.1.2 (2025-02-11)

### 修復：地圖邊界檢查問題

* **問題描述**：在運行模擬時出現以下錯誤：
  ```
  IndexError: list index out of range
  ```
  這個錯誤發生在`landscape.py`的`getNeighborObjectWithRadius`方法中，當機器人嘗試訪問地圖邊界之外的區域時。

* **錯誤原因**：
  1. 在`getNeighborObjectWithRadius`方法中，只檢查了坐標的下限（>= 0），但沒有檢查上限
  2. 當機器人接近地圖邊緣時，可能計算出超出地圖範圍的坐標
  3. 這導致`self.map[p[0]][p[1]]`嘗試訪問不存在的數組位置，引發索引越界錯誤

* **解決方案**：
  1. 在`landscape.py`的`getNeighborObjectWithRadius`方法中增加對坐標上限的檢查：
     ```python
     if i >= 0 and j >= 0 and i < self.dimension+1 and j < self.dimension+1:
     ```
  2. 在`robot.py`的`getNearestRobotConflictCandidate`方法中增加額外的安全檢查。

* **預防類似問題的建議**：
  1. 邊界檢查：所有涉及數組索引的操作都應該包含完整的邊界檢查
  2. 防禦性編程：假設輸入可能無效，並提前檢查和處理
  3. 單元測試：為邊界情況編寫測試，特別是涉及地圖邊緣的機器人行為
  4. 日誌記錄：在關鍵點添加日誌，以便在問題發生時更容易診斷

## v0.1.1 (2025-02-10)

### 修復：Station ID 屬性命名不一致問題

* **問題描述**：在運行模擬時出現以下錯誤：
  ```
  AttributeError: 'Picker' object has no attribute 'station_id'
  ```
  這個錯誤發生在`station_manager.py`的`findHighestSimilarityStation`方法中，當系統嘗試使用`station.station_id`屬性而不是正確的`station.id`屬性時。

* **錯誤原因**：
  1. `Object`基類（Station的父類）定義了`id`屬性（格式為`f"{object_type}-{id}"`，如"picker-0"）
  2. 在`station_manager.py`中錯誤地使用了`station.station_id`而不是`station.id`
  3. 並非所有實體都有`station_id`屬性，它只存在於`Order`和`Job`類中

* **解決方案**：
  1. 將`station_manager.py`中的`station.station_id`全部改為`station.id`
  2. 保持`Order`和`Job`類中使用的`station_id`不變，因為它們是正確的

* **預防類似問題的建議**：
  1. 統一命名規範：所有實體類屬性應遵循一致的命名模式
  2. 加強代碼審查：特別關注不同對象間的屬性引用
  3. 型別提示：使用Python的型別提示功能，有助於在開發階段發現類似問題
  4. 單元測試：增加測試覆蓋率，特別是對象之間的交互測試

## v0.1.26 (2023-03-15)

### 功能增強
- 將隊列基控制器應用於所有交叉路口，而不僅僅是主要交叉路口(15, 15)

### 分析
在原始代碼中，隊列基控制器(queue_based)被設計為只應用於主要交叉路口(15, 15)，其他交叉路口沒有使用此控制器進行交通管理。這可能導致其他交叉路口的交通效率較低，尤其是在高負載情況下。

### 解決方案
修改了`world/managers/intersection_manager.py`中的`update_traffic_using_controller`方法，移除了對隊列基控制器的特殊處理，使其能像其他控制器一樣應用於所有交叉路口。同時保留了對主要交叉路口(15, 15)的特殊日誌輸出，並為其他交叉路口添加了方向變更的日誌輸出。

### 技術細節
- 移除了條件判斷`if self.current_controller_type == "queue_based"`的特殊處理
- 統一了控制器對所有交叉路口的處理邏輯
- 為非主要交叉路口添加了方向變更的日誌輸出

### 修改文件
- `world/managers/intersection_manager.py`: 修改了`update_traffic_using_controller`方法

## [0.6.1] - 2025-03-05

### 功能：標記所有路口並添加ID標籤

* **功能描述**：在界面上標記所有實際路口位置並顯示其真實ID，使用與主要路口不同的顏色進行區分，以便於監控和測試不同路口的交通狀況。

* **實現細節**：
  1. 在 `netlogo.py` 中添加了 `get_all_intersections()` 函數，用於從後端獲取所有路口信息，包括坐標和ID。
  2. 修改了 `rmfs.nlogo` 中的 `setup` 函數，使其能夠從Python後端獲取路口位置信息。
  3. 為主要路口(15,15)使用粉紅色(135)標記，並顯示其實際ID。
  4. 為其他路口使用藍綠色(85)標記，並顯示其實際ID。
  5. 所有路口都使用白色標籤顯示ID，確保可讀性。

* **優勢**：
  1. 清晰顯示所有路口位置，便於監控整個路網結構。
  2. 顯示路口的實際ID，確保與後端系統數據一致，有助於調試和參考。
  3. 通過顏色區分主要路口和次要路口，凸顯主要路口的重要性。
  4. 改進從Python後端獲取實際路口信息的方式，使界面與後端數據保持一致。

* **修改文件**：
  - `netlogo.py`：添加了 `get_all_intersections()` 函數用於獲取路口信息。
  - `rmfs.nlogo`：修改了 `setup` 函數以支持從Python獲取路口位置並在界面上標記，並顯示其實際ID。

## v0.5.4 (2024-04-10)

### 修復：改進 NERL 控制器的評估機制

* **問題描述**：
  修復了 NERL 控制器長時間運行後仍會顯示 "No individuals evaluated yet, skipping evolution" 的問題。

#### 問題原因
* 在交通流量不足的情況下，個體可能長時間無法獲得評估機會
* 當交叉路口沒有機器人或機器人不需要做出決策時，狀態和動作不會被記錄
* 控制器缺乏適當的機制來處理長時間無法評估的情況

#### 解決方案
* 添加個體評估超時機制，如果當前個體超過500 ticks沒有被評估，則切換到下一個個體
* 增加連續未評估計數器，優化個體輪換策略
* 為重要方法添加診斷日誌，幫助追蹤評估和進化狀態
* 改進 `_evolve()` 方法的邏輯，優化無評估數據時的處理方式
* 確保在進化或切換個體時重置評估時間計數器

#### 修改的文件
* 修改: `ai/controllers/nerl_controller.py` - 改進個體評估和進化機制
* 修改: `CHANGELOG.md` - 更新版本信息

## v0.5.5 (2024-04-10)

### 改進：優化 DQN 控制器的訓練機制

* **改進描述**：
  優化了 DQN 控制器的訓練機制，增強其在低交通流量環境下的學習能力。

#### 功能改進
* 增加完善的診斷日誌，幫助追蹤訓練過程和記憶庫狀態
* 改進狀態和動作的記錄邏輯，確保在各種決策情境下都能正確收集訓練樣本
* 在強制方向切換和最小綠燈時間約束情況下，也記錄狀態和動作用於學習
* 優化訓練過程中的日誌輸出，每 500 ticks 顯示記憶庫大小和探索率
* 明確區分哪些情境適合用於訓練，哪些不適合

#### 修改的文件
* 修改: `ai/controllers/dqn_controller.py` - 優化訓練機制和診斷日誌
* 修改: `CHANGELOG.md` - 更新版本信息

## [Unreleased]

### Added
- 新增 NERL 控制器訓練模式和評估模式切換功能及相關 NetLogo 接口。
- 新增模型加載功能，允許加載指定 tick 保存的 NERL 模型。
- 新增列出可用模型的功能。
- 新增 NERL 模型保存功能，每 5000 ticks 保存最佳個體。
- 新增 DQN 模型保存功能，每 5000 ticks 自動保存。
- 新增 DQN 控制器加載特定 tick 模型的功能。
- 新增 DQN 和 NERL 控制器的防鎖死機制和最小綠燈時間規則。
- 新增 NERL 控制器參數（種群、精英、錦標賽、交叉、變異率/強度、進化間隔）。
- 新增 DQN 控制器參數（最小綠燈、偏好因子、最大等待閾值）。
- 為 DQN 和 NERL 添加了狀態空間、動作空間和神經網絡架構說明。
- 為 DQN 添加了獎勵函數設計說明。
- README 中增加了 DQN 和 NERL 控制器的詳細說明，包括狀態、動作、獎勵、架構、訓練和加載方式。
- 為 Queue-based 控制器添加了綠波機制和單向交通優化。
- README 中增加了訂單配置參數修改說明。
- README 中增加了調適訊息控制系統說明。
- README 中增加了 Queue-based 控制器的機器人狀態權重說明。
- 為 Queue-based 控制器綠波機制添加了短距離交叉路口優化。

### Changed
- 更新 README 中的使用方法，包含 DQN 和 NERL 的模型加載和模式切換說明。
- 更新 NERL 控制器的進化邏輯，使用精英保留、錦標賽選擇、均勻交叉和高斯變異。
- 更新 DQN 訓練邏輯，包括批次訓練、目標網絡更新和模型自動保存。
- 優化 Queue-based 控制器綠波機制，使用平方根距離衰減並增加基礎影響值。
- 增加 Queue-based 控制器識別相鄰交叉路口的距離至 15。

### Fixed
- (此處尚未記錄具體修復)

### Analyzed
- 分析並確認 NERL 控制器的適應度函數是基於與 DQN 相同的即時獎勵，在進化間隔內的累積平均值。
- 分析並確認 NERL 的進化間隔 `evolution_interval` 設為 15 ticks，評估基於此前 15 ticks 的表現。討論了該間隔長短的利弊，指出其為經驗性超參數。
- 釐清 DQN 的獎勵計算發生在每個 tick 基於有效的狀態轉移 (s, a, s') -> r，而網絡訓練則是以固定間隔（如 64 ticks）從經驗回放池採樣進行。
- 釐清 NERL 的適應度計算發生在每個進化間隔 (15 ticks) 結束時，基於該窗口內所有決策的平均即時獎勵。
- 分析代碼確認 DQN 訓練監控主要依賴間接觀察仿真 KPI 和基本訓練日誌（如記憶庫大小、epsilon），缺乏內建的 Loss、Q 值或累積獎勵追蹤。
- 分析代碼確認 NERL 進化監控主要依賴打印每一代（進化間隔）的最佳適應度 (`best_fitness`)，缺乏平均適應度追蹤和與仿真 KPI 的直接關聯記錄。

### Added
- 新增在 `ai/controllers/nerl_controller.py` 中對 `self.individual_eval_time` 和 `self.consecutive_no_evaluation` 的重置，以確保在進化後新個體的評估計時器被正確初始化。
- 新增在進化失敗且沒有個體被評估時，切換到下一個個體進行評估的邏輯，防止卡在無法評估的個體上。
- 新增診斷日誌，以便追蹤 NERL 控制器中的進化過程和個體評估狀態。
- 在 `DQNController` 的 `train` 方法中添加診斷日誌，以便追蹤缺少先前狀態或動作的情況。
- 在 `DQNController` 的 `train` 方法中添加診斷日誌，追蹤訓練觸發、記憶體大小和目標網絡更新。

### Changed
- 修改 `ai/controllers/nerl_controller.py` 的 `_evolve` 方法，確保只有在至少一個個體被評估後才執行進化，並添加相關日誌。
- 修改 `ai/controllers/nerl_controller.py` 的 `train` 方法，增加了個體評估超時機制，如果一個個體評估時間過長且未產生評估數據，則切換到下一個個體。
- 在 `ai/controllers/nerl_controller.py` 的 `train` 方法中移除對 `self.previous_states` 的不必要更新。

### Fixed
- 修正 `ai/controllers/nerl_controller.py` 中的 `_tournament_selection` 方法，確保返回的是索引而不是布爾值。

### Removed
- 移除 `ai/controllers/dqn_controller.py` 中 `train` 方法內不必要的 reward 計算 (已在外部計算)。

### Deprecated

### Security

### Docs
- 釐清 DQN 訓練停止條件：程式碼本身沒有定義自動停止條件，訓練會隨 NetLogo 模擬持續進行，模型會定期保存。需要手動停止模擬來結束訓練。
- 釐清訂單生成時間：訂單根據 `order_period_time` 參數，在模擬開始後的 3 或 5 小時內生成完畢（約 10800 或 18000 ticks），而非持續生成。
- 釐清訂單生成機制：訂單在模擬 setup 階段通過 `lib/generator/order_generator.py` 生成，基於泊松分佈（到達時間）、幾何分佈（物品種類數）、加權隨機選擇（具體物品）和常態分佈（物品數量）。若訂單檔 (`generated_order.csv` 等) 已存在，則直接使用，不重新生成。

## 2024-07-25

- 在`netlogo.py`的`tick`函數中加入英文調試日誌，以追蹤潛在的超時問題。

- 修復補貨站選擇邏輯，改為根據實際機器人負載 (robot_ids) 選擇，而非錯誤的訂單數量 (order_ids)，並為補貨站添加容量限制 (max_robots)。

### Fixed
- (此處尚未記錄具體修復)

### Added
- 新增 NERL 適應度追蹤功能，記錄每一代的最佳和平均適應度。
- 在性能報告中新增 NERL 適應度演化圖表，視覺化 Best Fitness 和 Average Fitness 隨世代的變化趨勢。

### Analyzed
- 分析並確認 NERL 控制器的適應度函數是基於與 DQN 相同的即時獎勵，在進化間隔內的累積平均值。

### Added
- 新增 NERL 適應度追蹤功能，記錄每一代的最佳和平均適應度。
- 在性能報告中新增 NERL 適應度演化圖表，視覺化 Best Fitness 和 Average Fitness 隨世代的變化趨勢。

### Changed
- 優化 NERL 進化觸發機制，確保每個模擬時間刻 (tick) 最多只觸發一次進化，而不是基於處理的交叉路口數量。

### Analyzed
- 分析並確認 NERL 控制器的適應度函數是基於與 DQN 相同的即時獎勵，在進化間隔內的累積平均值。

### Fixed
- 修復在 `IntersectionManager` 中因未匯入 `NEController` 導致的 `NameError`。

### Analyzed
- 分析並確認 NERL 控制器的適應度函數是基於與 DQN 相同的即時獎勵，在進化間隔內的累積平均值。

- 檢查並分析了揀貨台訂單分配邏輯 (`findHighestSimilarityStation`)。發現目前是基於 SKU 相似度分配，可能導致負載不均。

### Changed
- 修改揀貨台分配邏輯 (`findHighestSimilarityStation`)，結合 SKU 相似度和工作站當前負載（可用容量比例）計算綜合優先級分數。
- 調整揀貨台優先級分數計算權重，將可用容量比例 (`load_score`) 乘以最大訂單數 (`max_orders`)，使其與 SKU 相似度分數更具可比性。

## [Unreleased]

### Fixed
- 修復了 `world/warehouse.py` 中因找不到可用補貨站 (replenishment station) 而導致的 `AttributeError: 'NoneType' object has no attribute 'id'` 錯誤。加入了對 `station_replenish` 是否為 `None` 的檢查。

## [Unreleased]

### Changed
- 修改 `findAvailableReplenishmentStation` 邏輯 (`world/managers/station_manager.py`)：在所有補貨站都達到容量上限時，不再返回 `None`，而是選擇負載最低（即使已滿）的站點，以確保補貨任務總能被指派（只要存在補貨站）。

### Fixed
// ... existing code ...

- ## [未發行]
- 新增 NERL 控制器分析，解釋了獎勵機制、防鎖死邏輯以及在「卍」字鎖死情況下的失效原因。
- 闡明了局部視野是導致全局僵局的主要原因。

### v2.0.0 - 2025-06-15

### 2025-07-15

- **重構 (refactor)**
  - 調整 `lib/generator/warehouse_generator.py` 中的訂單生成參數，將 `order_period_time` 延長至 150 並將 `order_start_arrival_time` 設為 0。目的是為了在更長的訓練時間跨度內提供持續的訂單流，以支持模型訓練，並修正先前設定導致的啟動初期死鎖問題。


</rewritten_file>